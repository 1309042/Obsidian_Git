## ✅ **시간 복잡도란?**

- 시간 복잡도(Time Complexity)는 **입력 크기(n)에 따라 알고리즘이 실행되는 속도를 나타내는 개념이야**
- 쉽게 말해서 **데이터가 많아질수록 실행 시간이 얼마나 늘어나는지** **측정하는 거야.** 🚀


--------------
## 🎯 **대표적인 시간 복잡도 종류**
| **빅오 표기법**     | **이름**   | **설명**                         | **예제**              |
| -------------- | -------- | ------------------------------ | ------------------- |
| **O(1)**       | 상수 시간    | 입력 크기에 상관없이 일정한 시간에 실행됨        | 배열 인덱스 접근, 수학 공식    |
| **O(log n)**   | 로그 시간    | 입력이 많아져도 실행 시간이 조금씩만 증가        | 이진 탐색, 균형 이진 트리     |
| **O(n)**       | 선형 시간    | 입력이 많아질수록 실행 시간이 비례해서 증가       | 단순 반복문 (for, while) |
| **O(n log n)** | 로그 선형 시간 | `O(n)`보다 빠르지만 `O(log n)`보다는 느림 | 병합 정렬, 퀵 정렬         |
| **O(n²)**      | 제곱 시간    | 중첩 반복문으로 인해 실행 시간이 급격히 증가      | 버블 정렬, 선택 정렬        |
| **O(2ⁿ)**      | 지수 시간    | `n`이 커질수록 실행 시간이 폭발적으로 증가      | 피보나치(재귀)            |
| **O(n!)**      | 팩토리얼 시간  | `n`이 조금만 커져도 실행 시간이 너무 오래 걸림   | 외판원 문제 (TSP)        |

---

## ✅ **각 시간 복잡도 실행 속도 비교 (예제)**
| `n` 값        | **O(1)** | **O(log n)** | **O(n)**  | **O(n log n)** | **O(n²)** | **O(2ⁿ)** |
| ------------ | -------- | ------------ | --------- | -------------- | --------- | --------- |
| **10**       | 1        | 3            | 10        | 30             | 100       | 1024      |
| **100**      | 1        | 6            | 100       | 600            | 10,000    | `10³⁰`    |
| **1,000**    | 1        | 10           | 1,000     | 10,000         | 1,000,000 | `10³⁰⁰`   |
| **10⁶ (백만)** | 1        | 20           | 1,000,000 | 20,000,000     | `10¹²`    | ❌ 너무 큼    |

- **O(1), O(log n)은 데이터가 커져도 빠름!**
- **O(n²), O(2ⁿ)은 너무 느려서 현실적으로 불가능!** 😱

---

## ✅ **예제별 시간 복잡도 분석**
#### **1️⃣ O(1) → 상수 시간**

``` python
def get_first_element(arr):    
	return arr[0]  # 리스트 첫 번째 원소 접근 (항상 1번 연산)`
```

- **입력 크기(`n`)에 관계없이 항상 일정한 시간**에 실행됨.
- **대표적인 예제**: 배열 인덱스 접근, 수학 공식(`a + b = c`).

---

#### **2️⃣ O(log n) → 로그 시간 (이진 탐색)**

``` python
def binary_search(arr, target):     
	left, right = 0, len(arr) - 1     
	while left <= right:         
		mid = (left + right) // 2         
		if arr[mid] == target:             
			return mid         
		elif arr[mid] < target:             
			left = mid + 1         
		else:             
			right = mid - 1     
	return -1
```

- **데이터를 반씩 줄이면서 탐색** → `log n`
- **100만 개 데이터를 탐색해도 약 20번 연산만 하면 찾을 수 있음!** 🚀
- **대표적인 예제**: 이진 탐색, 로그 기반 알고리즘.

---

#### **3️⃣ O(n) → 선형 시간 (단순 반복문)**

``` python
def linear_search(arr, target):     
	for i in range(len(arr)):         
		if arr[i] == target:            
			return i     
	return -1
```
- **데이터 크기(`n`)만큼 실행됨** → `n=100만`이면 100만 번 실행!
- **대표적인 예제**: 단순 반복문, 리스트 탐색.

---

#### **4️⃣ O(n log n) → 로그 선형 시간 (퀵 정렬)**

``` python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + middle + quick_sort(right)
```

- **정렬 알고리즘에서 자주 등장**
- **대표적인 예제**: 퀵 정렬, 병합 정렬.

---

#### **5️⃣ O(n²) → 제곱 시간 (버블 정렬)**

``` python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
```

- **이중 반복문이 사용되므로 매우 느림!**
- **대표적인 예제**: 버블 정렬, 브루트포스 탐색.

---

#### **6️⃣ O(2ⁿ) → 지수 시간 (피보나치 재귀)**

``` python
def fibonacci(n):
    if n == 0: return 0
    if n == 1: return 1
    return fibonacci(n-1) + fibonacci(n-2)
```

- **입력값이 커질수록 실행 시간이 엄청 길어짐!** 😱
- **대표적인 예제**: 피보나치(재귀), 백트래킹.

---

## ✅ **달팽이 문제의 시간 복잡도**

- 백준 2869번

```python
import math 

A, B, V = map(int, input().split()) 
days = math.ceil((V - A) / (A - B)) + 1 
print(days)`

```

- **이 코드는 O(1) (상수 시간)!**
- **한 줄의 수학 연산으로 즉시 해결되므로 매우 빠름!** 🚀
- **반복문으로 하나씩 계산하면 O(n)이라서 비효율적!**

---

## ✅ **정리**

|복잡도|설명|예제|
|---|---|---|
|**O(1)**|항상 같은 시간에 실행됨|수학 공식, 배열 접근|
|**O(log n)**|입력이 많아져도 실행 시간이 조금씩 증가|이진 탐색|
|**O(n)**|입력 크기만큼 실행됨|단순 반복문|
|**O(n log n)**|정렬 알고리즘에서 자주 등장|퀵 정렬, 병합 정렬|
|**O(n²)**|중첩 반복문으로 인해 실행 시간이 급격히 증가|버블 정렬|
|**O(2ⁿ)**|피보나치(재귀)처럼 연산량이 기하급수적으로 증가|백트래킹|

💡 **시간 복잡도를 잘 고려해서 가장 빠른 방법을 선택하는 게 중요해!**  
**달팽이 문제처럼 O(1)로 해결할 수 있으면 반복문을 쓰지 말고 한 번에 풀자!** 😆🔥

이제 시간 복잡도에 대한 감이 확실히 잡혔지? 🚀💪  
어떤 문제든 **시간 복잡도를 분석해서 가장 빠른 알고리즘을 선택하는 습관을 들이면 돼!** 🎯
