---

---

| 시간 제한             | 메모리 제한 | 제출     | 정답    | 맞힌 사람 | 정답 비율   |
| ----------------- | ------ | ------ | ----- | ----- | ------- |
| 0.25 초 (추가 시간 없음) | 128 MB | 285379 | 91670 | 73415 | 31.608% |

#### 문제
땅 위에 달팽이가 있다. 이 달팽이는 높이가 V미터인 나무 막대를 올라갈 것이다.

달팽이는 낮에 A미터 올라갈 수 있다. 하지만, 밤에 잠을 자는 동안 B미터 미끄러진다. 또, 정상에 올라간 후에는 미끄러지지 않는다.

달팽이가 나무 막대를 모두 올라가려면, 며칠이 걸리는지 구하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 세 정수 A, B, V가 공백으로 구분되어서 주어진다. (1 ≤ B < A ≤ V ≤ 1,000,000,000)

#### 출력
첫째 줄에 달팽이가 나무 막대를 모두 올라가는데 며칠이 걸리는지 출력한다.

#### 예제 입력
2 1 5

#### 예제 출력
4


#### [나의 풀이]
```python
n = input()

# 하루동안 달팽이가 가는 거리 수
x = n[0] - n[1]
x_count = 0

for i in range(n[2]):
    while False:
        += x_count
    while Ture:
        break
        
```


❌ **코드의 문제점**
1. **`n = input()` → `int`로 변환 필요!**
	- input()은 문자열이므로, 숫자로 계산하려면 **`map(int, input().split())`** 으로 변환해야 해
2.  `n[0] - n[1]` → 잘못된 접근 방식
	- n은 **리스트가 아니라 문자열이기 때문에 n[0], n[1] 이런 방식으로 숫자를 추출하면 안돼**
	- 대신 `A, B, V = map(int, input().split())` 를 사용해야 해
3. **`while False:` -> `while True:` 의 오타**
	-  `while False:`는 **절대 실행되지 않음!** (`while True:`와 정반대)
	- `while Ture:` → `while True:` (오타 수정)
4. `+= x_count` → **변수 누락**
	- `+= x_count` 앞에 변수가 없어. (`x_count += something` 형태로 써야 함!)
5. **불필요한 반복문 사용**
	- `for i in range(n[2])` 같은 방식으로 푸는 것이 아니라, **수학적으로 O(1)로 해결하는 게 더 효율적!**

### ✅ **코드 설명**

1. **입력값 변환 (`map(int, input().split())`)**
    - A = 낮에 올라가는 거리
    - B = 밤에 미끄러지는 거리
    - V = 나무 막대 높이
2. **수학적 공식 적용**
    - `V - A` → 마지막 도착 전에 남은 거리
    - `A - B` → 하루에 올라갈 수 있는 실제 거리
    - `math.ceil((V - A) / (A - B))` → 필요한 날짜 계산 (올림 처리)
    - 마지막 날 추가 (`+1`)

## 🎯 **결론**

🚀 **반복문 없이 `O(1)`로 해결하는 게 더 빠름!**  
✅ **반복문 없이 수학적으로 계산하면, V 값이 커져도 빠르게 정답을 구할 수 있음!**


### [정답]
``` python
import math

# 공백으로 구분된 입력을 받음 (A: 낮에 올라가는 거리, B: 밤에 미끄러지는 거리, V: 나무 높이)
A, B, V = map(int, input().split())

# 정상 도착 전까지 필요한 거리 계산
days = math.ceil((V - A) / (A - B)) + 1

# 결과 출력
print(days)
```

#### 📌 **공식**
```
필요한 거리 = V - A               #(마지막 날을 제외한 남은 거리)
하루 동안 올라가는 거리 = A - B    #(실제 하루에 올라가는 거리)
필요한 날짜 = (V - A) / (A - B)   #(소수점이 나오면 올림 처리)
마지막 날 추가 = +1
```






